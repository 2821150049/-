# 模板

## 一、概念

​		c++提供了函数模板(function template.)所谓函数模板，**实际上是建立一个通用函数，其函数类型和形参类型不具体制定，用一个虚拟的类型来代表。这个通用函数就成为函数模板。**凡是函数体相同的函数都可以用这个模板代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。

​		模板机制：`函数模板`和`类模板`。

​		补充：模板把函数或类要处理的数据类型参数化，表现为参数的多态性，成为类属。l 模板用于表达逻辑结构相同，但具体数据元素类型不同的数据对象的通用行为。

## 二、函数模板

1. 什么是函数模版

函数模板，**实际上是建立一个通用函数，其函数类型和形参类型不具体制定，用一个虚拟的类型来代表。这个通用函数就成为函数模板**。

2. 函数模板的编写方式

   1. `class`

   ```C++
   // T代表泛型的数据类型，不是只能写T，
   template<class T>// 让编译器看到这句话后面紧跟着的函数里有T不要报错
   void mySwap(T &a,T &b)
   {
   	T tmp = a;
   	a = b;
   	b = tmp;
   }
   ```

   2. `typename`

   ```C++
   template<typename T>
   void func2(T a,T b)
   {
   
   }
   ```

3. 使用

```C++
//T代表泛型的数据类型，不是只能写T，
template<class T>//让编译器看到这句话后面紧跟着的函数里有T不要报错
void mySwap(T &a,T &b){
	T tmp = a;
	a = b;
	b = tmp;
}

template<class T>
void mySwap2() {
}
//使用函数模版
void test02(){
	int a = 10;
	int b = 20;
	//1.编译器会根据实参来自动推导数据类型
	mySwap(a,b);
	cout << "a=" << a << endl;
	cout << "b=" << b << endl;
	char c = 'c';
	//mySwap(a, c);err,数据类型要一致
	//2.显示的指定类型
	mySwap<int>(a, b);//<>用参数列表告诉编译器我只传int类
	//mySwap<double>(a, b);//注意：指定类型，传入数据时数据类型必须一致
	mySwap<>(a,b);
	//mySwap2<>();//err 调用时，必须让编译器知道泛型T具体是什么类型
}
```

4. 编译器会对函数模版和类模版进行二次编译
5. 隐式转换

```C++
template<class T>
T func(T a, T b){
	return a + b;
}
void test03(){
	int a = 10;
	double b = 20.2;
	//如果使用参数列表指定数据类型，那么实参中可以隐式转换，
	//如果转换成功，就调用，转换不成功就报错
	cout << func<int>(10,20.2) << endl;
}
```

6. 普通函数与函数模板调用规则
   1. 普通函数可以进行隐式转换
   2. 函数模版不能直接的进行隐式转换
   3. 如果要进行隐性转换，必须加上参数列表

7. 实现机制

   1. 编译器并不是把函数模板处理成能够处理任何类型的函数
   2. 函数模板通过具体类型产生不同的函数
   3. 编译器会对函数模板进行`两次编译`，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。

8. 模板的局限性

   1. T不能是数组或者其他类型数据

   2. 解决方法：

      1. 具体化函数模板`(不建议)`

         ```C++
         template<class T>
         T func(T a, T b){
         	return a + b;
         }
         //具体化优先于常规模板
         template<>Maker func(Maker a, Maker b){
         	return a.age + b.;
         }
         ```

      2. 重载符号



## 三、类模板

1. 类模版是把类中的数据类型参数化

```C++
template<class NameType,class AgeType>
class Maekr{
public:
	Maekr(NameType name, AgeType age){
		this->name = name;
		this->age = age;
	}
public:
	NameType name;
	AgeType age;
};
```

2. 类模板使用

```C++
void test(){
	//1.类模版不会自动推导数据类型，要显示的告诉编译器是什么类型
	Maker<string,int> m("悟空",18);
	m.printMaker();

	//2.注意传入的参数,传入参数类型要程序员自己把握
	Maker<int, int> m2(18, 20);
	m2.printMaker();
	//Maker<> m3("aaa",18);err,必须通过参数列表告诉编译器是什么类型
}
```

3. 类模版的默认参数(了解)

```C++
//类模版的默认类型
template<class NameType, class AgeType=int>
class Maker2{
public:
	Maker2(NameType name, AgeType age){
		this->name = name;
		this->age = age;
	}
	void printMaker(){
		cout << "Name:" << this->name << " Age:" << this->age << endl;
	}
public:
	NameType name;
	AgeType age;
};

void test02(){
	//如果有默认类型，那么<>里可以少写类型
	Maker2<string> m("贝吉塔", 20);
	m.printMaker();
	//以传入的类型为准
	Maker2<string, double> m2("wukong", 20.22);
	m2.printMaker();
}
```

4. 注意事项

```C++
//默认类型后面的泛型类型都必须有默认类型
template<class NameType, class AgeType = int,class T=int>
class Maker3 {
public:
	Maker3(NameType name, AgeType age) {
		this->name = name;
		this->age = age;
	}
	void printMaker(){
		cout << "Name:" << this->name << " Age:" << this->age << endl;
	}
public:
	NameType name;
	AgeType age;
};
```

5. 类模板作为函数参数

   1. 指定传入类型

   ```C
   //1.指定传入的数据类型
   void func(Maker<string,int> &m){
   	m.printMaker();
   }
   ```

   2. 参数模板化

   ```C
   //2.参数模版化（常用）
   template<class T1,class T2>
   void func2(Maker<T1,T2> &m){
   	m.printMaker();
   }
   ```

   3. 整个类模板化

   ```C++
   //3.整个类模版化
   template<class T>
   void func3(T &m){
   	m.printMaker();
   }
   ```

   










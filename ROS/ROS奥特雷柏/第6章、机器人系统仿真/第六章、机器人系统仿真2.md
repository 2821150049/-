# 第六章、机器人系统仿真

## 6.1. 概述

对于ROS新手而言，可能会有疑问:学习机器人操作系统，实体机器人是必须的吗？答案是否定的，机器人一般价格不菲，为了降低机器人学习、调试成本，在ROS中提供了系统的机器人仿真实现，通过仿真，可以实现大部分需求，本章主要就是围绕“仿真”展开的，比如，本章会介绍:

- 如何创建并显示机器人模型；
- 如何搭建仿真环境；
- 如何实现机器人模型与仿真环境的交互。

本章预期的学习目标如下:

- 能够独立使用URDF创建机器人模型，并在Rviz和Gazebo中分别显示；
- 能够使用Gazebo搭建仿真环境；
- 能够使用机器人模型中的传感器(雷达、摄像头、编码器...)获取仿真环境数据。

## 6.2. URDF集成Rviz基本流程

前面介绍过，URDF 不能单独使用，需要结合 Rviz 或 Gazebo，URDF 只是一个文件，需要在 Rviz 或 Gazebo 中渲染成图形化的机器人模型，当前，首先演示URDF与Rviz的集成使用，因为URDF与Rviz的集成较之于URDF与Gazebo的集成更为简单，后期，基于Rviz的集成实现，我们再进一步介绍URDF语法。

**需求描述:**

在 Rviz 中显示一个盒状机器人。

**实现流程：**

1. 准备:新建功能包，导入依赖

   1. 创建urdf01_rviz功能包
   2. 导入依赖`urdf`和`xacro`
   3. 创建需要用到的文件夹`config`、`launch`、`meshes`、`urdf\urdf`、`urdf\xacro`

   <img src="img-\1.png" alt="1" style="zoom:50%;" />

2. 核心:编写 `urdf` 文件

   1. 在`urdf`文件夹下创建`demo_helloworld.urdf`文件，将下面内容复制粘贴进去

   ```xml
   <robot name="mycar">
       <link name="base_link">
           <visual>
               <geometry>
                   <box size="0.5 0.2 0.1" />
               </geometry>
           </visual>
       </link>
   </robot>

3. 核心:在 launch 文件集成 URDF 与 Rviz

   + 在launch文件中创建`demo_helloworld.urdf`导入创建的模型文件，并打开Rviz

   ```xml
   <launch>
       <!-- 载入 urdf 文件,这个参数是固定的 -->
       <param name="robot_car" textfile="$(find urdf01_rviz)/urdf/urdf/demo01_helloworld.urdf" />
       <!-- 启动rviz -->
       <node pkg="rviz" type="rviz" name="rviz" />
   </launch>

4. 在 Rviz 中显示机器人模型

![2](img-\2.png)

## 6.3. URDF语法

**URDF中存在的标签：**官网链接：https://wiki.ros.org/urdf/XML

### robot

1. `robot`：类似于`launch`根标签

   1. **参数：**`name`，用于定义当前机器人的名字

   ```xml
   <!-- name(required)(string):定义机器人名字 -->
   <robot name="robot">
     	<!-- robot robot links and joints and more -->
   </robot>
   ```

   2. **子标签**

   其他标签都是子集标签。

2. `sensor`：robot内的子集标签，用于设置传感器的标签。

   1. **参数：**`name`，`type`，`id`，`update_rate`。

   ```xml
   <!-- name(required)(string):定义传感器名字 -->
   <!-- type(required)(string):定义传感器类型，有camera, ray, imu, magnetometer, gps, force_torque, contact, sonar, rfidtag, rfid等 -->
   <!-- id(optional)(string):定义传感器编号 -->
   <!-- update_rate(optional)(float):定义传感器数据更新的周期 -->
   <sensor name="my_camera_sensor" update_rate="20">
       <!-- 里面的内容可以不用管 -->
     	<parent link="optical_frame_link_name"/>
      	<origin xyz="0 0 0" rpy="0 0 0"/>
      	<camera>
        	<image width="640" height="480" hfov="1.5708" format="RGB8" near="0.01" far="50.0"/>
      	</camera>
   </sensor>
   ```

   2. 子标签

   https://wiki.ros.org/urdf/XML/sensor/proposals

3. `link`连杆标签

   1. **参数：**`name`

   ```xml
   <!-- name(required)(string):定义连杆名字 -->
   <link name="my_link">
       <!-- 惯性相关子标题 -->
   	<inertial>
        	<origin xyz="0 0 0.5" rpy="0 0 0"/>
        	<mass value="1"/>
        	<inertia ixx="100"  ixy="0"  ixz="0" iyy="100" iyz="0" izz="100" />
   	</inertial>
       <!-- 可视化连杆标题，常用的是这个 -->
      	<visual>
           <!-- origin设置偏移量与倾斜弧度，属性1: xyz=x偏移 y偏移 z偏移，属性2: rpy=x翻滚 y俯仰 z偏航 (单位是弧度)-->
        	<origin xyz="0 0 0" rpy="0 0 0" />
           <!-- geometry设置连杆的形状 -->
        	<geometry>
               <!-- 标签1: box(盒状) 参数:size=长(x) 宽(y) 高(z)-->
          		<box size="1 1 1" />
               <!-- 标签2: cylinder(圆柱) 参数:radius=半径 length=高度-->
          		<cylinder radius="0.5" length="0.1" />
               <!-- 标签3: sphere(球体) 参数:radius=半径-->
          		<sphere radius="0.3" />
               <!-- 标签4: mesh(为连杆添加皮肤) 参数: filename=资源路径(格式:package://<packagename>/<path>/文件)-->
          		<mesh filename="资源路径" />
        	</geometry>
           <!-- material设置材料属性(颜色),参数name材料名字 -->
        	<material name="Cyan">
               <!-- color设置颜色,参数: rgba=红绿蓝权重值与透明度 (每个权重值以及透明度取值[0,1]) -->
          		<color rgba="0 1.0 1.0 1.0"/>
        	</material>
      	</visual>
       <!-- 碰撞相关子标题 -->
      	<collision>
        	<origin xyz="0 0 0" rpy="0 0 0"/>
        	<geometry>
          		<cylinder radius="1" length="0.5"/>
        	</geometry>
      	</collision>
   </link>
   ```

   2. 子标签：

   https://wiki.ros.org/urdf/XML/link

4. `transmision`：暂时不知道具体功能https://wiki.ros.org/urdf/XML/Transmission

5. `joint`：关节标签

   1. **参数：**`name`，`type`

   ```xml
   <!-- name(required)(string):定义关节名字 -->
   <!-- type(required)(string):定义关节属性，关节属性有六种 -->
   <!-- continuous: 旋转关节，可以绕单轴无限旋转，revolute: 旋转关节，类似于 continues,但是有旋转角度限制，prismatic: 滑动关节，沿某一轴线移动的关节，有位置极限，planer: 平面关节，允许在平面正交方向上平移或旋转，floating: 浮动关节，允许进行平移、旋转运动，fixed: 固定关节，不允许运动的特殊关节 -->
   <joint name="my_joint" type="floating">
       <!-- 下面三个标签是必须的，origin计算两个link中心的偏移量 -->
       <parent link="link1"/>
       <child link="link2"/>
   	<origin xyz="0 0 1" rpy="0 0 3.1416"/>
       <!-- 设置围绕x,y,z那个关节旋转 -->
       <axis xyz="0 0 1" />
   </joint>
   ```

   2. **子标签**

   https://wiki.ros.org/urdf/XML/joint

6. 等[gazebo](https://wiki.ros.org/urdf/XML/Gazebo)，[model_state](https://wiki.ros.org/urdf/XML/model_state)，[model](https://wiki.ros.org/urdf/XML/model)，[sensor](https://wiki.ros.org/urdf/XML/sensor)。

**注意：**

+ **joint中的origin设置的偏移量是parent和child link的偏移量，是以两个link的中心作为偏移量设置的。**

+ **添加joint后，需要发布与joint相关的坐标变化话题，不过这个话题，ros已经帮忙内置了，在launch文件中加入下面三条语句就行，第一二条是发布tf坐标变换话题的，后一条是启动gui的**

```xml
<!-- 启动机器人状态和关节状态发布节点 -->
    <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher" />
    <node pkg="joint_state_publisher" type="joint_state_publisher" name="joint_state_publisher" />
    <!-- 启动图形化的控制关节运动节点，控制结点运动的节点，此结点不是必须的 -->
    <node pkg="joint_state_publisher_gui" type="joint_state_publisher_gui" name="joint_state_publisher_gui" />
```

+ **在调用上面的静态`tf`变换时，我们所用到的launch中机器人名称必须为 `robot_description`，不用就会报错。**

7. **案例**

> 创建一个四轮圆柱状机器人模型，机器人参数如下,底盘为圆柱状，半径 10cm，高 8cm，四轮由两个驱动轮和两个万向支撑轮组成，两个驱动轮半径为 3.25cm,轮胎宽度1.5cm，两个万向轮为球状，半径 0.75cm，底盘离地间距为 1.5cm(与万向轮直径一致)(做个大概)

**urdf文件，搭建机器人模型**

```xml
<robot name="demo02_car">
    <!-- car_base-->
    <link name="base_link">
        <visual>
            <geometry>
                <cylinder radius="0.1" length="0.08" />
            </geometry>
            <origin xyz="0 0 0.055" rpy="0 0 0" />
            <material name="r">
       		    <color rgba="0 1.0 0 1.0"/>
            </material>
        </visual>
    </link>
    <!-- car_wheel -->
    <link name="car_L_wheel">
        <visual>
            <geometry>
                <cylinder radius="0.0325" length="0.015" />
            </geometry>
            <material name="w">
       		    <color rgba="1.0 0.0 0.0 1.0"/>
            </material>       
        </visual>
    </link>
    <joint name="left_wheelbase_link" type="continuous">
        <parent link="base_link" />
        <child link="car_L_wheel" />
        <origin xyz="0 0.1 0.0325" rpy="1.5705 0 0" />
        <axis xyz="0 1 0" />
    </joint>
    <link name="car_R_wheel">
        <visual>
            <geometry>
                <cylinder radius="0.0325" length="0.015" />
            </geometry>
            <material name="w">
       		    <color rgba="1.0 0.0 0.0 1.0"/>
            </material>
        </visual>
    </link>
    <joint name="right_wheelbase_link" type="continuous">
        <parent link="base_link" />
        <child link="car_R_wheel" />
        <origin xyz="0 -0.1 0.0325" rpy="1.5705 0 0" />
        <axis xyz="0 1 0" />
    </joint>
</robot>
```

**创建launch文件**

```xml
<launch>
    <!-- 这里的param共享参数的name设置的值必须是robot_description，否则就会抛异常 -->
    <param name="robot_description" textfile="$(find urdf01_rviz)/urdf/urdf/show_my_car.rviz" />
    <node pkg="rviz" type="rviz" name="rviz" args="-d $(find urdf01_rviz)/config/show_my_car.rviz" />

    <!-- 启动机器人状态和关节状态发布节点 -->
    <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher" />
    <node pkg="joint_state_publisher" type="joint_state_publisher" name="joint_state_publisher" />
    <!-- 启动图形化的控制关节运动节点,这个节点是用来控制结点运动的节点 -->
    <node pkg="joint_state_publisher_gui" type="joint_state_publisher_gui" name="joint_state_publisher_gui" />
</launch>
```

#### URDF工具

**语法检查工具**

1. 有可能没有安装这个检测工具，调用下面的指令进行安装。

```bash
sudo apt install liburdfdom-tools
```

2. `cd`到`urdf`文件所在文件夹下调用下面的指令进行urdf文件的检查

```bash
check_urdf name.urdf
```

![3](img-\3.png)

**结构查看工具**

```bash
urdf_to_graphiz name.urdf
```

## 6.4. xacro语法

http://wiki.ros.org/xacro

在xacro文件夹下定义`xxx.xacro`文件

1. **属性定义**

```xml
<!-- 这里定义的属性，其实有点像定义了一个变量，name是变量名，value是变量值 -->
<!-- 根标签，必须声明 xmlns:xacro -->
<robot name="my_base" xmlns:xacro="http://www.ros.org/wiki/xacro">
    <!-- 定义 -->
	<xacro:property name="xxxx" value="yyyy" />
    <!-- 调用 -->
    ${xxxx}
    ${表达式}
</robot>
```

*栗子:*

```xml
<xacro:property name="wheel_radius" value="0.0325" /><!-- 半径 -->
<xacro:property name="wheel_length" value="0.015" /><!-- 宽度 -->
<geometry>
    <cylinder radius="${wheel_radius}" length="${wheel_length}" />
</geometry>
```

2. **宏**

```xml
<!-- 这里的宏，很想函数，name就像函数名，params就像函数参数，多个函数参数用逗号隔开 -->
<xacro:macro name="宏名称" params="参数列表(多参数之间使用空格分隔)">
    .....
    参数调用格式: ${参数名}
</xacro:macro>
```

**宏调用**

```xml
<xacro:宏名称 参数1=xxx 参数2=xxx />
```

*栗子：*

```XML
<!-- 定义了轮子的宏 -->
<xacro:macro name="add_wheels" params="name flag">
    <link name="${name}_wheel">
        <visual>
            <geometry>
                <cylinder radius="${wheel_radius}" length="${wheel_length}" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="${PI / 2} 0.0 0.0" />
            <material name="black" />
        </visual>
    </link>

    <joint name="${name}_wheel2base_link" type="continuous">
        <parent link="base_link" />
        <child link="${name}_wheel" />
        <origin xyz="0 ${flag * base_link_radius} ${-(earth_space + base_link_length / 2 - wheel_radius) }" />
        <axis xyz="0 1 0" />
    </joint>
</xacro:macro>
<!-- 调用，创建左轮子和右轮子 -->
<xacro:add_wheels name="left" flag="1" />
<xacro:add_wheels name="right" flag="-1" />
```

3. **文件包含**

​		机器人由多部件组成，不同部件可能封装为单独的 xacro 文件，最后再将不同的文件集成，组合为完整机器人，可以使用文件包含实现

```xml
<xacro:include filename="name.xacro" />
```

*栗子：*

```xml
<robot name="xxx" xmlns:xacro="http://wiki.ros.org/xacro">
      <xacro:include filename="my_base.xacro" />
      <xacro:include filename="my_camera.xacro" />
      <xacro:include filename="my_laser.xacro" />
</robot>
```

#### 实战

##### 机器人模型创建

1. 在xacro文件夹中创建`mycar_base.urdf.xacro`文件：用于创建小车底盘

```xml
<!--
    使用 xacro 优化 URDF 版的小车底盘实现：
    实现思路:
    1.将一些常量、变量封装为 xacro:property
      比如:PI 值、小车底盘半径、离地间距、车轮半径、宽度 ....
    2.使用 宏 封装驱动轮以及支撑轮实现，调用相关宏生成驱动轮与支撑轮
-->
<!-- 根标签，必须声明 xmlns:xacro -->
<robot name="my_base" xmlns:xacro="http://www.ros.org/wiki/xacro">
    <!-- 封装变量、常量 -->
    <xacro:property name="PI" value="3.141"/>
    <!-- 宏:黑色设置 -->
    <material name="black">
        <color rgba="0.0 0.0 0.0 1.0" />
    </material>
    <!-- 底盘属性 -->
    <xacro:property name="base_footprint_radius" value="0.001" /> <!-- base_footprint 半径  -->
    <xacro:property name="base_link_radius" value="0.1" /> <!-- base_link 半径 -->
    <xacro:property name="base_link_length" value="0.08" /> <!-- base_link 长 -->
    <xacro:property name="earth_space" value="0.015" /> <!-- 离地间距 -->
    <!-- 底盘 -->
    <link name="base_footprint">
      <visual>
        <geometry>
          <sphere radius="${base_footprint_radius}" />
        </geometry>
      </visual>
    </link>
    <link name="base_link">
      <visual>
        <geometry>
          <cylinder radius="${base_link_radius}" length="${base_link_length}" />
        </geometry>
        <origin xyz="0 0 0" rpy="0 0 0" />
        <material name="yellow">
          <color rgba="0.5 0.3 0.0 0.5" />
        </material>
      </visual>
    </link>
    <joint name="base_link2base_footprint" type="fixed">
      <parent link="base_footprint" />
      <child link="base_link" />
      <origin xyz="0 0 ${earth_space + base_link_length / 2 }" />
    </joint>
    <!-- 驱动轮 -->
    <!-- 驱动轮属性 -->
    <xacro:property name="wheel_radius" value="0.0325" /><!-- 半径 -->
    <xacro:property name="wheel_length" value="0.015" /><!-- 宽度 -->
    <!-- 驱动轮宏实现 -->
    <xacro:macro name="add_wheels" params="name flag">
      <link name="${name}_wheel">
        <visual>
          <geometry>
            <cylinder radius="${wheel_radius}" length="${wheel_length}" />
          </geometry>
          <origin xyz="0.0 0.0 0.0" rpy="${PI / 2} 0.0 0.0" />
          <material name="black" />
        </visual>
      </link>
      <joint name="${name}_wheel2base_link" type="continuous">
        <parent link="base_link" />
        <child link="${name}_wheel" />
        <origin xyz="0 ${flag * base_link_radius} ${-(earth_space + base_link_length / 2 - wheel_radius) }" />
        <axis xyz="0 1 0" />
      </joint>
    </xacro:macro>
    <xacro:add_wheels name="left" flag="1" />
    <xacro:add_wheels name="right" flag="-1" />
    <!-- 支撑轮 -->
    <!-- 支撑轮属性 -->
    <xacro:property name="support_wheel_radius" value="0.0075" /> <!-- 支撑轮半径 -->
    <!-- 支撑轮宏 -->
    <xacro:macro name="add_support_wheel" params="name flag" >
      <link name="${name}_wheel">
        <visual>
            <geometry>
                <sphere radius="${support_wheel_radius}" />
            </geometry>
            <origin xyz="0 0 0" rpy="0 0 0" />
            <material name="black" />
        </visual>
      </link>
      <joint name="${name}_wheel2base_link" type="continuous">
          <parent link="base_link" />
          <child link="${name}_wheel" />
          <origin xyz="${flag * (base_link_radius - support_wheel_radius)} 0 ${-(base_link_length / 2 + earth_space / 2)}" />
          <axis xyz="1 1 1" />
      </joint>
    </xacro:macro>
    <xacro:add_support_wheel name="front" flag="1" />
    <xacro:add_support_wheel name="back" flag="-1" />
</robot>
```

2. 创建`my_camera.urdf.xacro`文件：用于创建摄像头

```xml
<!-- 摄像头相关的 xacro 文件 -->
<robot name="my_camera" xmlns:xacro="http://wiki.ros.org/xacro">
    <!-- 摄像头属性 -->
    <xacro:property name="camera_length" value="0.01" /> <!-- 摄像头长度(x) -->
    <xacro:property name="camera_width" value="0.025" /> <!-- 摄像头宽度(y) -->
    <xacro:property name="camera_height" value="0.025" /> <!-- 摄像头高度(z) -->
    <xacro:property name="、" value="0.08" /> <!-- 摄像头安装的x坐标 -->
    <xacro:property name="camera_y" value="0.0" /> <!-- 摄像头安装的y坐标 -->
    <xacro:property name="camera_z" value="${base_link_length / 2 + camera_height / 2}" /> <!-- 摄像头安装的z坐标:底盘高度 / 2 + 摄像头高度 / 2  -->
    <!-- 摄像头关节以及link -->
    <link name="camera">
        <visual>
            <geometry>
                <box size="${camera_length} ${camera_width} ${camera_height}" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
            <material name="black" />
        </visual>
    </link>
    <joint name="camera2base_link" type="fixed">
        <parent link="base_link" />
        <child link="camera" />
        <origin xyz="${camera_x} ${camera_y} ${camera_z}" />
    </joint>
</robot>
```

3. 创建`my_laser.urdf.xacro`文件：用于创建激光雷达

```xml
<!--
    小车底盘添加雷达
-->
<robot name="my_laser" xmlns:xacro="http://wiki.ros.org/xacro">
    <!-- 雷达支架 -->
    <xacro:property name="support_length" value="0.15" /> <!-- 支架长度 -->
    <xacro:property name="support_radius" value="0.01" /> <!-- 支架半径 -->
    <xacro:property name="support_x" value="0.0" /> <!-- 支架安装的x坐标 -->
    <xacro:property name="support_y" value="0.0" /> <!-- 支架安装的y坐标 -->
    <xacro:property name="support_z" value="${base_link_length / 2 + support_length / 2}" /> <!-- 支架安装的z坐标:底盘高度 / 2 + 支架高度 / 2  -->
    <link name="support">
        <visual>
            <geometry>
                <cylinder radius="${support_radius}" length="${support_length}" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
            <material name="red">
                <color rgba="0.8 0.2 0.0 0.8" />
            </material>
        </visual>
    </link>
    <joint name="support2base_link" type="fixed">
        <parent link="base_link" />
        <child link="support" />
        <origin xyz="${support_x} ${support_y} ${support_z}" />
    </joint>
    <!-- 雷达属性 -->
    <xacro:property name="laser_length" value="0.05" /> <!-- 雷达长度 -->
    <xacro:property name="laser_radius" value="0.03" /> <!-- 雷达半径 -->
    <xacro:property name="laser_x" value="0.0" /> <!-- 雷达安装的x坐标 -->
    <xacro:property name="laser_y" value="0.0" /> <!-- 雷达安装的y坐标 -->
    <xacro:property name="laser_z" value="${support_length / 2 + laser_length / 2}" /> <!-- 雷达安装的z坐标:支架高度 / 2 + 雷达高度 / 2  -->
    <!-- 雷达关节以及link -->
    <link name="laser">
        <visual>
            <geometry>
                <cylinder radius="${laser_radius}" length="${laser_length}" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
            <material name="black" />
        </visual>
    </link>
    <joint name="laser2support" type="fixed">
        <parent link="support" />
        <child link="laser" />
        <origin xyz="${laser_x} ${laser_y} ${laser_z}" />
    </joint>
</robot>
```

4. 创建 `my_car_camera.urdf`

```xml
<!-- 组合小车底盘与摄像头与雷达 -->
<robot name="my_car_camera" xmlns:xacro="http://wiki.ros.org/xacro">
    <!-- 包含上面创建的3个文件 -->
    <xacro:include filename="mycar_base.urdf.xacro" />
    <xacro:include filename="my_camera.urdf.xacro" />
    <xacro:include filename="my_laser.urdf.xacro" />
</robot>
```

##### 调用实现

```xml
<launch>
    <!-- 加载robot_description时使用command属性，属性值就是调用 xacro 功能包的 xacro 程序直接解析 xacro 文件。 -->
    <param name="robot_description" command="$(find xacro)/xacro $(find urdf01_rviz)/urdf/xacro/my_car_camera.urdf.xacro" />
	
    <node pkg="rviz" type="rviz" name="rviz" args="-d $(find urdf01_rviz)/config/show_mycar.rviz" />
    <node pkg="joint_state_publisher" type="joint_state_publisher" name="joint_state_publisher" output="screen" />
    <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher" output="screen" />
    <node pkg="joint_state_publisher_gui" type="joint_state_publisher_gui" name="joint_state_publisher_gui" output="screen" />

</launch>
```

## 6.5. Arbotix使用流程

这是一个控制仿真机器人运动包，安装方式

```xml
<!-- 命令行调用 -->
sudo apt-get install ros-[<VersionName()>]-arbotix
<!-- 将 [<VsersionName()>] 替换成当前 ROS 版本名称，如果提示功能包无法定位，请采用方式2。 -->
<!-- 源码安装 -->
git clone https://github.com/vanadiumlabs/arbotix_ros.git
```

源码安装过程中，将下载下来的源码复制粘贴到工作空间下，然后编译，编译没有报错，则成功导入。

1. 在`config`中编写配置文件`control.yaml`

```yaml
# 该文件是控制器配置,一个机器人模型可能有多个控制器，比如: 底盘、机械臂、夹持器(机械手)....
# 因此，根 name 是 controller
controllers: {
   # 单控制器设置
   base_controller: {
          #类型: 差速控制器
       type: diff_controller,
       #参考坐标
       base_frame_id: base_footprint, 
       #两个轮子之间的间距
       base_width: 0.2,
       #控制频率
       ticks_meter: 2000, 
       #PID控制参数，使机器人车轮快速达到预期速度
       Kp: 12, 
       Kd: 12, 
       Ki: 0, 
       Ko: 50, 
       #加速限制
       accel_limit: 1.0 
    }
}
```

2. 编写`control_car_arbotic.launch`配置文件

```xml
<launch>
    <param name="robot_description" command="$(find xacro)/xacro $(find urdf01_rviz)/urdf/xacro/my_car_camera.urdf.xacro" />
    <node pkg="rviz" type="rviz" name="rviz" args="-d $(find urdf01_rviz)/config/show_mycar.rviz" />
    <node pkg="joint_state_publisher" type="joint_state_publisher" name="joint_state_publisher" output="screen" />
    <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher" output="screen" />
    <!-- 集成arbotix控制节点 -->
    <node name="arbotix" pkg="arbotix_python" type="arbotix_driver" output="screen">
        <rosparam file="$(find urdf01_rviz)/config/control.yaml" command="load" />
        <param name="sim" value="true" />
    </node>
</launch>
```

3. 调用launch文件，并将fix坐标系配置为`odom`

4. 若出现运行报错或者说是没有odom坐标系

![](img-\5.png)

在终端运行下面三条指令

```bash
sudo apt-get update
sudo apt install python3-pip
sudo pip3 install pyserial
```

5. 就可以正常运行了

调用`rostopic pub`指令让小车动起来

```bash
rostopic pub -r 10 /cmd_vel geometry_msgs/Twist '{linear: {x: 0.2, y: 0, z: 0}, angular: {x: 0, y: 0, z: 0.5}}'
```

## 6.6. Gazebo和URDF集成

### 1.基本操作

1. 编写URDF文件

在urdf文件夹下创建 `demo01_urdf_gazebo.urdf`文件，文件内容如下。

```xml
<!-- 
    创建一个机器人模型(盒状即可)，显示在 Gazebo 中 
-->
<robot name="mybox">
    <link name="base_link">
        <visual>
            <geometry>
                <box size="0.5 0.2 0.1" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
            <material name="yellow">
                <color rgba="0.5 0.3 0.0 1" />
            </material>
        </visual>
        <!-- 在gazebo中需要添加collision碰撞检测 -->
        <collision>
            <!-- 如果是标准的几何图像，直接照搬geometry和origin -->
            <geometry>
                <box size="0.5 0.2 0.1" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
        </collision>
        <!-- inertial惯性矩阵也是必须的 -->
        <inertial>
            <origin xyz="0 0 0" />
            <mass value="6" />
            <inertia ixx="1" ixy="0" ixz="0" iyy="1" iyz="0" izz="1" />
        </inertial>
    </link>
    <!-- 在rviz中设置的颜色不能在gazebo中显示，需要重新设置 -->
    <!-- 
        <gazebo reference="关节">
            <material>Gazebo/颜色</material>
        </gazebo>
     -->
    <gazebo reference="base_link">
        <material>Gazebo/Black</material>
    </gazebo>
</robot>
```

这里还是照常的配置`urdf`文件，但是必须加入`collision`和`inertial`两个标签，因为仿真过程中需要用到碰撞检测参数和惯性矩阵参数。并且配置相应link在gazebo中的颜色。

2. 在`launch`文件夹下创建 `demo01_urdf_gazebo.launch`文件

```xml
<launch>
    <!-- 将 Urdf 文件的内容加载到参数服务器 -->
    <param name="robot_description" textfile="$(find urdf02_gazebo)/urdf/urdf/demo01_urdf_gazebo.urdf" />
    <!-- 启动 gazebo,这个是默认的 -->
    <include file="$(find gazebo_ros)/launch/empty_world.launch" />
    <!-- 在 gazebo 中显示机器人模型，默认的配置 -->
    <!-- 
        在 Gazebo 中加载一个机器人模型，该功能由 gazebo_ros 下的 spawn_model 提供:
        -urdf 加载的是 urdf 文件
        -model mycar 模型名称是 mycar
        -param robot_description 从参数 robot_description 中载入模型
        -x 模型载入的 x 坐标
        -y 模型载入的 y 坐标
        -z 模型载入的 z 坐标
	-->
    <node pkg="gazebo_ros" type="spawn_model" name="model" args="-urdf -model mycar -param robot_description"  />
</launch>
```

### 2.Gazebo集成小车

由基本操作我们可以知道，想要将小车导入到Gazebo中，那么对于xacro所创建的模型而言，只需要加入`collision`碰撞检测，`inertial`惯性矩阵和颜色即可。

1. 创建小车底盘 `my_base.urdf.xacro`文件

```xml
<!--
    使用 xacro 优化 URDF 版的小车底盘实现：

    实现思路:
    1.将一些常量、变量封装为 xacro:property
      比如:PI 值、小车底盘半径、离地间距、车轮半径、宽度 ....
    2.使用 宏 封装驱动轮以及支撑轮实现，调用相关宏生成驱动轮与支撑轮

-->
<!-- 根标签，必须声明 xmlns:xacro -->
<robot name="my_base" xmlns:xacro="http://www.ros.org/wiki/xacro">
    <!-- 封装变量、常量 -->
    <xacro:property name="PI" value="3.141"/>
    <!-- 宏:黑色设置 -->
    <material name="black">
        <color rgba="0.0 0.0 0.0 1.0" />
    </material>
    <!-- 底盘属性 -->
    <xacro:property name="base_footprint_radius" value="0.001" /> <!-- base_footprint 半径  -->
    <xacro:property name="base_footprint_mass" value="0.001" /> <!-- base_footprint 半径  -->
    <xacro:property name="base_link_radius" value="0.1" /> <!-- base_link 半径 -->
    <xacro:property name="base_link_length" value="0.08" /> <!-- base_link 长 -->
    <xacro:property name="base_link_mass" value="0.08" /> <!-- base_link 长 -->
    <xacro:property name="earth_space" value="0.015" /> <!-- 离地间距 -->
    <!-- 底盘 -->
    <link name="base_footprint">
      <visual>
        <geometry>
          <sphere radius="${base_footprint_radius}" />
        </geometry>
      </visual>
      <collision>
        <!-- 如果是标准的几何图像，直接照搬geometry和origin -->
        <geometry>
          <sphere radius="${base_footprint_radius}" />
        </geometry>
        <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
      </collision>
      <!-- inertial惯性矩阵也是必须的 -->
      <xacro:sphere_inertial_matrix m="${base_footprint_mass}" r="${base_footprint_radius}" />
    </link>
    <!-- 设置颜色 -->
    <gazebo reference="base_footprint">
      <material>Gazebo/Red</material>
    </gazebo>

    <link name="base_link">
      <visual>
        <geometry>
          <cylinder radius="${base_link_radius}" length="${base_link_length}" />
        </geometry>
        <origin xyz="0 0 0" rpy="0 0 0" />
        <material name="yellow">
          <color rgba="0.5 0.3 0.0 0.5" />
        </material>
      </visual>
      <collision>
        <!-- 如果是标准的几何图像，直接照搬geometry和origin -->
        <geometry>
          <cylinder radius="${base_link_radius}" length="${base_link_length}" />
        </geometry>
        <origin xyz="0 0 0" rpy="0 0 0" />
      </collision>
      <!-- inertial惯性矩阵也是必须的 -->
      <xacro:cylinder_inertial_matrix m="${base_link_mass}" r="${base_link_radius}" h="${base_link_length}" />
    </link>
    <gazebo reference="base_link">
      <material>Gazebo/Yellow</material>
    </gazebo>
    <joint name="base_link2base_footprint" type="fixed">
      <parent link="base_footprint" />
      <child link="base_link" />
      <origin xyz="0 0 ${earth_space + base_link_length / 2 }" />
    </joint>
    <!-- 驱动轮 -->
    <!-- 驱动轮属性 -->
    <xacro:property name="wheel_radius" value="0.0325" /><!-- 半径 -->
    <xacro:property name="wheel_mass" value="0.1" /><!-- 轮子质量 -->
    <xacro:property name="wheel_length" value="0.015" /><!-- 宽度 -->
    <!-- 驱动轮宏实现 -->
    <xacro:macro name="add_wheels" params="name flag">
      <link name="${name}_wheel">
        <visual>
          <geometry>
            <cylinder radius="${wheel_radius}" length="${wheel_length}" />
          </geometry>
          <origin xyz="0.0 0.0 0.0" rpy="${PI / 2} 0.0 0.0" />
          <material name="black" />
        </visual>
        <collision>
          <!-- 如果是标准的几何图像，直接照搬geometry和origin -->
          <geometry>
              <cylinder radius="${wheel_radius}" length="${wheel_length}" />
          </geometry>
          <origin xyz="0.0 0.0 0.0" rpy="${PI / 2} 0.0 0.0" />
        </collision>
        <!-- inertial惯性矩阵也是必须的 -->
        <xacro:cylinder_inertial_matrix m="${wheel_mass}" r="${wheel_radius}" h="${wheel_length}" />
      </link>
      <gazebo reference="${name}_wheel">
        <material>Gazebo/Red</material>
      </gazebo>
      <joint name="${name}_wheel2base_link" type="continuous">
        <parent link="base_link" />
        <child link="${name}_wheel" />
        <origin xyz="0 ${flag * base_link_radius} ${-(earth_space + base_link_length / 2 - wheel_radius) }" />
        <axis xyz="0 1 0" />
      </joint>
    </xacro:macro>
    <xacro:add_wheels name="left" flag="1" />
    <xacro:add_wheels name="right" flag="-1" />
    <!-- 支撑轮 -->
    <!-- 支撑轮属性 -->
    <xacro:property name="support_wheel_radius" value="0.0075" /> <!-- 支撑轮半径 -->
    <xacro:property name="support_wheel_mass" value="0.0075" /> <!-- 支撑轮质量 -->

    <!-- 支撑轮宏 -->
    <xacro:macro name="add_support_wheel" params="name flag" >
      <link name="${name}_wheel">
        <visual>
            <geometry>
                <sphere radius="${support_wheel_radius}" />
            </geometry>
            <origin xyz="0 0 0" rpy="0 0 0" />
            <material name="black" />
        </visual>
        <collision>
          <!-- 如果是标准的几何图像，直接照搬geometry和origin -->
          <geometry>
              <sphere radius="${support_wheel_radius}" />
          </geometry>
          <origin xyz="0 0 0" rpy="0 0 0" />
        </collision>
        <!-- inertial惯性矩阵也是必须的 -->
        <xacro:sphere_inertial_matrix m="${support_wheel_mass}" r="${support_wheel_radius}" />
      </link>
      <gazebo reference="${name}_wheel">
        <material>Gazebo/Black</material>
      </gazebo>
      <joint name="${name}_wheel2base_link" type="continuous">
          <parent link="base_link" />
          <child link="${name}_wheel" />
          <origin xyz="${flag * (base_link_radius - support_wheel_radius)} 0 ${-(base_link_length / 2 + earth_space / 2)}" />
          <axis xyz="1 1 1" />
      </joint>
    </xacro:macro>
    <xacro:add_support_wheel name="front" flag="1" />
    <xacro:add_support_wheel name="back" flag="-1" />
</robot>
```

2. 创建 `my_camera.urdf.xacro`

```xml
<!-- 摄像头相关的 xacro 文件 -->
<robot name="my_camera" xmlns:xacro="http://wiki.ros.org/xacro">
    <!-- 摄像头属性 -->
    <xacro:property name="camera_mass" value="0.1" /> <!-- 摄像头长度(x) -->
    <xacro:property name="camera_length" value="0.01" /> <!-- 摄像头长度(x) -->
    <xacro:property name="camera_width" value="0.025" /> <!-- 摄像头宽度(y) -->
    <xacro:property name="camera_height" value="0.025" /> <!-- 摄像头高度(z) -->
    <xacro:property name="camera_x" value="0.08" /> <!-- 摄像头安装的x坐标 -->
    <xacro:property name="camera_y" value="0.0" /> <!-- 摄像头安装的y坐标 -->
    <xacro:property name="camera_z" value="${base_link_length / 2 + camera_height / 2}" /> <!-- 摄像头安装的z坐标:底盘高度 / 2 + 摄像头高度 / 2  -->

    <!-- 摄像头关节以及link -->
    <link name="camera">
        <visual>
            <geometry>
                <box size="${camera_length} ${camera_width} ${camera_height}" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
            <material name="black" />
        </visual>
        <collision>
            <!-- 如果是标准的几何图像，直接照搬geometry和origin -->
            <geometry>
                <box size="${camera_length} ${camera_width} ${camera_height}" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
        </collision>
        <!-- inertial惯性矩阵也是必须的 -->
        <xacro:Box_inertial_matrix m="${camera_mass}" l="${camera_length}" w="${camera_width}" h="${camera_height}"/>
    </link>
    <gazebo reference="camera">
        <material>Gazebo/Black</material>
    </gazebo>

    <joint name="camera2base_link" type="fixed">
        <parent link="base_link" />
        <child link="camera" />
        <origin xyz="${camera_x} ${camera_y} ${camera_z}" />
    </joint>
</robot>
```

3. 创建 `my_laser.urdf.xacro`

```xml
<!--
    小车底盘添加雷达
-->
<robot name="my_laser" xmlns:xacro="http://wiki.ros.org/xacro">

    <!-- 雷达支架 -->
    <xacro:property name="support_length" value="0.15" /> <!-- 支架长度 -->
    <xacro:property name="support_radius" value="0.01" /> <!-- 支架半径 -->
    <xacro:property name="support_mass" value="0.1" /> <!-- 支架质量 -->
    <xacro:property name="support_x" value="0.0" /> <!-- 支架安装的x坐标 -->
    <xacro:property name="support_y" value="0.0" /> <!-- 支架安装的y坐标 -->
    <xacro:property name="support_z" value="${base_link_length / 2 + support_length / 2}" /> <!-- 支架安装的z坐标:底盘高度 / 2 + 支架高度 / 2  -->

    <link name="support">
        <visual>
            <geometry>
                <cylinder radius="${support_radius}" length="${support_length}" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
            <material name="red">
                <color rgba="0.8 0.2 0.0 0.8" />
            </material>
        </visual>
        <collision>
            <!-- 如果是标准的几何图像，直接照搬geometry和origin -->
            <geometry>
                <cylinder radius="${support_radius}" length="${support_length}" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
        </collision>
        <!-- inertial惯性矩阵也是必须的 -->
        <xacro:cylinder_inertial_matrix m="${support_mass}" r="${support_radius}" h="${support_length}"/>
    </link>
    <gazebo reference="support">
        <material>Gazebo/Black</material>
    </gazebo>

    <joint name="support2base_link" type="fixed">
        <parent link="base_link" />
        <child link="support" />
        <origin xyz="${support_x} ${support_y} ${support_z}" />
    </joint>

    <!-- 雷达属性 -->
    <xacro:property name="laser_length" value="0.05" /> <!-- 雷达长度 -->
    <xacro:property name="laser_radius" value="0.03" /> <!-- 雷达半径 -->
    <xacro:property name="laser_mass" value="0.05" /> <!-- 雷达质量 -->
    <xacro:property name="laser_x" value="0.0" /> <!-- 雷达安装的x坐标 -->
    <xacro:property name="laser_y" value="0.0" /> <!-- 雷达安装的y坐标 -->
    <xacro:property name="laser_z" value="${support_length / 2 + laser_length / 2}" /> <!-- 雷达安装的z坐标:支架高度 / 2 + 雷达高度 / 2  -->

    <!-- 雷达关节以及link -->
    <link name="laser">
        <visual>
            <geometry>
                <cylinder radius="${laser_radius}" length="${laser_length}" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
            <material name="black" />
        </visual>
        <collision>
            <!-- 如果是标准的几何图像，直接照搬geometry和origin -->
            <geometry>
                <cylinder radius="${laser_radius}" length="${laser_length}" />
            </geometry>
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
        </collision>
        <!-- inertial惯性矩阵也是必须的 -->
        <xacro:cylinder_inertial_matrix m="${laser_mass}" r="${laser_radius}" h="${laser_length}"/>
    </link>
    <gazebo reference="laser">
        <material>Gazebo/Blue</material>
    </gazebo>

    <joint name="laser2support" type="fixed">
        <parent link="support" />
        <child link="laser" />
        <origin xyz="${laser_x} ${laser_y} ${laser_z}" />
    </joint>
</robot>
```

4. 创建惯性矩阵集成文档 `my_inertial.urdf.xacro`

```xml
<robot name="base" xmlns:xacro="http://wiki.ros.org/xacro">
    <!-- Macro for inertia matrix -->
    <!-- 球体惯性矩阵 -->
    <xacro:macro name="sphere_inertial_matrix" params="m r">
        <inertial>
            <mass value="${m}" />
            <inertia ixx="${2*m*r*r/5}" ixy="0" ixz="0"
                iyy="${2*m*r*r/5}" iyz="0" 
                izz="${2*m*r*r/5}" />
        </inertial>
    </xacro:macro>
    <!-- 圆柱惯性矩阵 -->
    <xacro:macro name="cylinder_inertial_matrix" params="m r h">
        <inertial>
            <mass value="${m}" />
            <inertia ixx="${m*(3*r*r+h*h)/12}" ixy = "0" ixz = "0"
                iyy="${m*(3*r*r+h*h)/12}" iyz = "0"
                izz="${m*r*r/2}" /> 
        </inertial>
    </xacro:macro>
    <!-- 立方体惯性矩阵 -->
    <xacro:macro name="Box_inertial_matrix" params="m l w h">
       <inertial>
               <mass value="${m}" />
               <inertia ixx="${m*(h*h + l*l)/12}" ixy = "0" ixz = "0"
                   iyy="${m*(w*w + l*l)/12}" iyz= "0"
                   izz="${m*(w*w + h*h)/12}" />
       </inertial>
   </xacro:macro>
</robot>
```

5. 汇总所有部件 `my_car.urdf.xacro`

```xml
<!-- 组合小车底盘与摄像头与雷达 -->
<robot name="my_car_camera" xmlns:xacro="http://wiki.ros.org/xacro">
    
    <xacro:include filename="my_inertial.urdf.xacro" />
    <xacro:include filename="my_base.urdf.xacro" />
    <xacro:include filename="my_camera.urdf.xacro" />
    <xacro:include filename="my_laser.urdf.xacro" />
</robot>
```

6. 创建launch文件 `my_car.launch`

```xml
<launch>
    <!-- 将 Urdf 文件的内容加载到参数服务器 -->
    <!-- command="$(find xacro)/xacro $(find urdf02_gazebo)/urdf/xacro/my_car.urdf.xacro"这个参数的前面一个参数固定的，后一个参数是xacro文件 -->
    <param name="robot_description" command="$(find xacro)/xacro $(find urdf02_gazebo)/urdf/xacro/my_car.urdf.xacro" />
    <!-- 启动 gazebo,这个是默认的 -->
    <include file="$(find gazebo_ros)/launch/empty_world.launch" />
    <!-- 在 gazebo 中显示机器人模型，默认的配置 -->
    <node pkg="gazebo_ros" type="spawn_model" name="model" args="-urdf -model mycar -param robot_description"  />
</launch>
```

### 3. Gazebo仿真环境搭建

1. 下载仿真环境

```xml
链接：https://pan.baidu.com/s/1zOiRcG2m4b9Ros_aDypALw 
提取码：6666 
--来自百度网盘超级会员V5的分享
官网链接：
git clone https://github.com/osrf/gazebo_models
```

2. 在功能包下创建 `worlds`文件夹，将 `box_house.world`导入。
3. 在launch文件中导入地图

```xml
<launch>
    <!-- 将 Urdf 文件的内容加载到参数服务器 -->
    <param name="robot_description" command="$(find xacro)/xacro $(find urdf02_gazebo)/urdf/xacro/my_car.urdf.xacro" />
    <!-- 启动 gazebo,这个是默认的 -->
    <!-- <include file="$(find gazebo_ros)/launch/empty_world.launch" /> -->
    <!-- 启动 gazebo,包含运行环境 -->
    <include file="$(find gazebo_ros)/launch/empty_world.launch" >
        <arg name="world_name" value="$(find urdf02_gazebo)/worlds/box_house.world" />
    </include>
    <!-- 在 gazebo 中显示机器人模型，默认的配置 -->
    <node pkg="gazebo_ros" type="spawn_model" name="model" args="-urdf -model mycar -param robot_description" />
</launch>
```

### 4. URDF、Gazebo、Rviz联合仿真

配置：http://gazebosim.org/tutorials?tut=ros_gzplugins

1. 创建 `gazebo_car.urdf.xacro` 文件-添加小车控制节点

```xml
<robot name="gazebo_car" xmlns:xacro="http://wiki.ros.org/xacro">
    <!-- 传动实现:用于连接控制器与关节 -->
    <xacro:macro name="joint_trans" params="joint_name">
        <!-- Transmission is important to link the joints and the controller -->
        <transmission name="${joint_name}_trans">
            <type>transmission_interface/SimpleTransmission</type>
            <joint name="${joint_name}">
                <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>
            </joint>
            <actuator name="${joint_name}_motor">
                <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>
                <mechanicalReduction>1</mechanicalReduction>
            </actuator>
        </transmission>
    </xacro:macro>
    <!-- 每一个驱动轮都需要配置传动装置 -->
    <xacro:joint_trans joint_name="left_wheel2base_link" />
    <xacro:joint_trans joint_name="right_wheel2base_link" />
    <!-- 底盘控制控制器 -->
    <gazebo>
        <plugin name="differential_drive_controller" filename="libgazebo_ros_diff_drive.so">
            <rosDebugLevel>Debug</rosDebugLevel>
            <publishWheelTF>true</publishWheelTF>
            <robotNamespace>/</robotNamespace>
            <publishTf>1</publishTf>
            <publishWheelJointState>true</publishWheelJointState>
            <alwaysOn>true</alwaysOn>
            <updateRate>100.0</updateRate>
            <legacyMode>true</legacyMode>
            <leftJoint>left_wheel2base_link</leftJoint> <!-- 左轮 -->
            <rightJoint>right_wheel2base_link</rightJoint> <!-- 右轮 -->
            <wheelSeparation>${base_link_radius * 2}</wheelSeparation> <!-- 车轮间距 -->
            <wheelDiameter>${wheel_radius * 2}</wheelDiameter> <!-- 车轮直径 -->
            <broadcastTF>1</broadcastTF>
            <wheelTorque>30</wheelTorque>
            <wheelAcceleration>1.8</wheelAcceleration>
            <commandTopic>cmd_vel</commandTopic> <!-- 运动控制话题 -->
            <odometryFrame>odom</odometryFrame> 
            <odometryTopic>odom</odometryTopic> <!-- 里程计话题 -->
            <robotBaseFrame>base_footprint</robotBaseFrame> <!-- 根坐标系 -->
        </plugin>
    </gazebo>
</robot>
```

2. 创建 `gazebo_laster.urdf.xacro` 文件-在gazebo中导入雷达节点

```xml
<robot name="gazebo_laster" xmlns:xacro="http://wiki.ros.org/xacro">
  <!-- 雷达 -->
  <!-- reference被引用的link,根据实际书写 -->
  <gazebo reference="laser">
    <sensor type="ray" name="rplidar">
      <pose>0 0 0 0 0 0</pose>
      <visualize>true</visualize>
      <update_rate>5.5</update_rate>
      <ray>
        <scan>
          <horizontal>
            <samples>360</samples>
            <resolution>1</resolution>
            <min_angle>-3</min_angle>
            <max_angle>3</max_angle>
          </horizontal>
        </scan>
        <range>
          <min>0.10</min>
          <max>30.0</max>
          <resolution>0.01</resolution>
        </range>
        <noise>
          <type>gaussian</type>
          <mean>0.0</mean>
          <stddev>0.01</stddev>
        </noise>
      </ray>
      <plugin name="gazebo_rplidar" filename="libgazebo_ros_laser.so">
        <topicName>/scan</topicName>
        <frameName>laser</frameName>
      </plugin>
    </sensor>
  </gazebo>
</robot>
```

3. 创建 `gazebo_camera.urdf.xacro` 文件-导入摄像头

```xml
<robot name="gazebo_camera" xmlns:xacro="http://wiki.ros.org/xacro">
  <!-- 被引用的link -->
  <gazebo reference="camera">
    <!-- 类型设置为 camara -->
    <sensor type="camera" name="camera_node">
      <update_rate>30.0</update_rate> <!-- 更新频率 -->
      <!-- 摄像头基本信息设置 -->
      <camera name="head">
        <horizontal_fov>1.3962634</horizontal_fov>
        <image>
          <width>1280</width>
          <height>720</height>
          <format>R8G8B8</format>
        </image>
        <clip>
          <near>0.02</near>
          <far>300</far>
        </clip>
        <noise>
          <type>gaussian</type>
          <mean>0.0</mean>
          <stddev>0.007</stddev>
        </noise>
      </camera>
      <!-- 核心插件 -->
      <plugin name="gazebo_camera" filename="libgazebo_ros_camera.so">
        <alwaysOn>true</alwaysOn>
        <updateRate>0.0</updateRate>
        <cameraName>/camera</cameraName>
        <imageTopicName>image_raw</imageTopicName>
        <cameraInfoTopicName>camera_info</cameraInfoTopicName>
        <frameName>camera</frameName>
        <hackBaseline>0.07</hackBaseline>
        <distortionK1>0.0</distortionK1>
        <distortionK2>0.0</distortionK2>
        <distortionK3>0.0</distortionK3>
        <distortionT1>0.0</distortionT1>
        <distortionT2>0.0</distortionT2>
      </plugin>
    </sensor>
  </gazebo>
</robot>
```

4. 创建 `gazebo_kinect.urdf.xacro` 文件

```xml
<robot name="gazebo_kinect" xmlns:xacro="http://wiki.ros.org/xacro">
    <gazebo reference="camera">  
      <sensor type="depth" name="camera">
        <always_on>true</always_on>
        <update_rate>20.0</update_rate>
        <camera>
          <horizontal_fov>${60.0*PI/180.0}</horizontal_fov>
          <image>
            <format>R8G8B8</format>
            <width>640</width>
            <height>480</height>
          </image>
          <clip>
            <near>0.05</near>
            <far>8.0</far>
          </clip>
        </camera>
        <plugin name="kinect_camera_controller" filename="libgazebo_ros_openni_kinect.so">
          <cameraName>camera</cameraName>
          <alwaysOn>true</alwaysOn>
          <updateRate>10</updateRate>
          <imageTopicName>rgb/image_raw</imageTopicName>
          <depthImageTopicName>depth/image_raw</depthImageTopicName>
          <pointCloudTopicName>depth/points</pointCloudTopicName>
          <cameraInfoTopicName>rgb/camera_info</cameraInfoTopicName>
          <depthImageCameraInfoTopicName>depth/camera_info</depthImageCameraInfoTopicName>
          <frameName>camera</frameName>
          <baseline>0.1</baseline>
          <distortion_k1>0.0</distortion_k1>
          <distortion_k2>0.0</distortion_k2>
          <distortion_k3>0.0</distortion_k3>
          <distortion_t1>0.0</distortion_t1>
          <distortion_t2>0.0</distortion_t2>
          <pointCloudCutoff>0.4</pointCloudCutoff>
        </plugin>
      </sensor>
    </gazebo>
</robot>
```

5. 汇总创建 `gazebo_modular.urdf.xacro` 文件

```xml
<!-- 组合小车底盘与摄像头与雷达 -->
<robot name="gazebo_modular" xmlns:xacro="http://wiki.ros.org/xacro"> 
    <!-- 小车底盘 -->
    <xacro:include filename="gazebo_car.urdf.xacro" />
    <!-- 激光雷达 -->
    <xacro:include filename="gazebo_laster.urdf.xacro" />
    <!-- 摄像头 -->
    <xacro:include filename="gazebo_camera.urdf.xacro" />
    <!-- 深度相机 -->
    <!-- <xacro:include filename="gazebo_kinect.urdf.xacro" /> -->
</robot> 
```

6. 创建 `my_car.launch` 文件

```xml
<launch>
    <!-- 将 Urdf 文件的内容加载到参数服务器 -->
    <param name="robot_description" command="$(find xacro)/xacro $(find urdf02_gazebo)/urdf/xacro/my_car.urdf.xacro" />

    <node pkg="rviz" type="rviz" name="rviz" args="-d $(find urdf01_rviz)/config/show_las.rviz" />
    <!-- 关节以及机器人状态发布节点 -->
    <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher" />
    <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" />
    <!-- 启动 gazebo,这个是默认的 -->
    <!-- <include file="$(find gazebo_ros)/launch/empty_world.launch" /> -->
    <!-- 启动 gazebo,包含运行环境  -->
    <include file="$(find gazebo_ros)/launch/empty_world.launch" >
        <arg name="world_name" value="$(find urdf02_gazebo)/worlds/box_house.world" />
    </include>
    <!-- 在 gazebo 中显示机器人模型 -->
    <node pkg="gazebo_ros" type="spawn_model" name="model" args="-urdf -model mycar -param robot_description"  />
</launch>
```

# 第八章、排序

[toc]

## 一、基本概念和排序方法概述

**知识总览：**

![3](img\3.png)

### 1.基本概念

排序就是重新排列表中元素，使表中的元素满足*按关键字有序*的过程。

![1](img\1.png)

### 2.性能指标

1. 时间复杂度
2. 空间复杂度
3. 稳定性

> 算法的稳定性。若待排序表中有两个元素`Ri`和`Rj`，其对应的关键字相同即`keyi` = `keyj`，且在排序 前`Ri`在`Rj`的前⾯，若使用某一排序算法排序后，`Ri`仍然在`Rj`的前⾯，则称这个排序算法是稳定的，否则称排序算法是不稳定的。

举个栗子：

![2](img\2.png)

**注意：算法稳定性一定比不稳定的好嘛，当然是不一定，要看时间需求。**

### 3.排序算法的分类

1. 内部排序：数据在内存中，就好比定义了一个数组
2. 外部排序：数据太多，无法存放在内存，存在磁盘中。

## 二、插入排序

> 算法思想：每次将⼀个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。

*给你个动图自己体会*

![4](img\4.gif)

### 1.直插排序

1. 概念引入

> 下面我们来说说直接插入，其实上面的动图就已经很好的诠释了直接插入排序的思想。

2. 代码实现

```c++
// A表示需要排序的数组，n是数据个数
void InsertSort(int A[], int n) {
    int i, j, temp;
    for (i = 1; i < n; i++) {
        if (A[i] < A[i - 1]) {	// 按从小到大的顺序进行插入排序
            temp = A[i];
            for (j = i - 1; j >= 0 && A[j] > temp; --j)
                A[j + 1] = A[j];	// 向后移动数
            A[j + 1] = temp;
        }
    }
}
// 当要按从大到小的顺序排序时，需要修改两个地方
/*
第5行  A[i] < A[i - 1]-->A[i] > A[i - 1]
第7行  A[j] > temp-->A[j] < temp
*/
```

3. 算法特性

> 空间复杂度：$O(1)$
> 最好时间复杂度（全部有序）：$O(n)$
> 最坏时间复杂度（全部逆序）：$O(n^2)$
> 平均时间复杂度：$O(n^2)$​​
> 算法稳定性：稳定

### 2.折半插入排序

1. 概述

> 折半插入排序顾名思义就是先用折半查找的方式找到需要排序的位置，在进行插入，查找的方式是用折半查找的方式。

2. 代码实现

```c++
void InsertSort(int A[],int n){
    int i,j,low,high,mid,temp;
    for(i = 1;i < n;i++){
        temp = A[i];
        low = 0;
        high = i-1;
        while(low <= high){
            mid = (low + high)/2;
            if(temp >= A[mid])
                low = mid + 1;
            else
                high = mid - 1;
        }
        for(j = i-1;j >= high + 1;j--)
            A[j+1] = A[j];
        A[high+1] = temp;
    }
}
```





### 3.希尔排序





## 三、交换排序

### 1.冒泡排序



### 2.快速排序







## 四、选择排序

### 1.简单选择排序



### 2.树形选择排序



### 3.堆排序



## 五、归并排序





## 六、基数排序

### 1.多关键字排序



### 2.链式基数排序





## 七、外部排序

### 1.外部排序基本方法



### 2.多路平衡归并的实现



### 3.置换-选择排序



### 4.最佳归并树






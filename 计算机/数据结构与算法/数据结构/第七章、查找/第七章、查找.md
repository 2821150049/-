# 第七章、查找

## 一、线性查找

**知识预览**

<img src="C:/Users/XF/Desktop/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E6%9F%A5%E6%89%BE/img/1.png" alt="1" style="zoom:50%;" />

基本概念：

1. **查找：**在数据集合中寻找满⾜某种条件的数据元素的过程称为查找。

2. **查找表：**⽤于查找的数据集合称为查找表，它由*同⼀类型*的数据元素（或记录）组成。

3. **关键字：**数据元素中唯⼀标识该元素的某个数据项的值，使⽤基于关键字的查找，查找结果应该是*唯⼀的*。

4. **查找算法的评估标准：**

   在查找运算中，需要对⽐关键字的次数称为*查找⻓度*，*平均查找⻓度*（ASL, Average Search Length）—— 所有查找过程中进⾏关键字的⽐较次数的平均值。

   $$\color{red}ASL=\sum_{i=1}^nP_iC_i $$​​​，ASL 的数量级反应了查找算法时间复杂度。
   
5. **查找长度：**在查找运算中，需要对比关键字的次数称为查找长度。

### 1.顺序查找

**知识总览:**

![2](C:/Users/XF/Desktop/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E6%9F%A5%E6%89%BE/img/2.png)

1. 概念：顺序查找，⼜叫“线性查找”，通常⽤于线性表。
2. 算法思想：从头到 jio 挨个找（或者反过来也OK）
3. 算法实现：

```c
typedef struct {		// 查找表的数据结构
    ElemType *elem;	// 动态数组的基地址
    int TableLen;	// 表长
}SSTable;
// 顺序查找
int Search_Seq(SSTable ST,ElemType key) {
    for(int i = 0;i < ST.TableLen;i++) {
        if(ST.elem[i] == key) {
            return i;	// 成功返回下标
        }
    }
    return -1;	// 失败返回-1
}
// 优化
/* 优点:⽆需判断是否越界，效率更⾼ */
int Search_Seq(SSTable ST,ElemType key) {
    ST.elem[0] = key;//数据从下标1开始存
    for(int i = ST.TableLen;ST.elem[i] != key; --i);
    return i;	// 查找成功返回元素下标，失败返回0
}
```

4. `ASL`

$ASL = \frac{1+2+3...+n}{n}=\frac{n+1}{2}$​

5. **顺序查找的时间复杂度= $O(n)$**

### 2.折半查找

**知识总览：**

![3](C:/Users/XF/Desktop/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E6%9F%A5%E6%89%BE/img/3.png)

1. 概念：折半查找，⼜称“⼆分查找”，仅适⽤于有序的顺序表。

2. 算法思想：

```
如果从文件中读取的数据记录的关键字是有序排列的（递增的或是递减的），则可以用一种更有效率的查找方法来查找文件中的记录，这就是折半查找法，又称为二分搜索。
折半查找的基本思想：减少查找序列的长度，分而治之地进行关键字的查找。他的查找过程是：先确定待查找记录的所在的范围，然后逐渐缩小查找的范围，直至找到该记录为止（也可能查找失败）。例如文件记录的关键字序列为：
　　　　（1，3，5，7，9，11，13，17，21，28，32）
该序列包含11个元素，而且关键字单调递增。现在想查找关键字key为28的记录。如果应用顺序查找法进行查找，需要将28之前的所有关键字与key进行比较，共需10次，如果用折半查找可以这样做：
设指针low和high分别指向关键字序列的上界和下界，即low=0,high=10。指针mid指向序列的中间位置，即mid=[(low+high)/2]=5。在这里low指向关键字1，high指向关键字32，mid指向关键字11。
　　　　（1，3，5，7，9，11，13，17，21，28，32）
　　　　　↑ 　　　　　　　↑　　　　　　　　　　↑
　　　　　low　　　　　　mid　　　　　　　　　high
　(1)首先将mid所指向的元素与key进行比较，因为key=28，大于11，这就是说明待查找的关键字一定位于mid和high之间。这是因为原关键字序列是有序递增的。因此下面的查找工作只需在[mid+1,high]中进行。于是指针low指向mid+1的位置，即low=6,也就是指向关键字13,并将mid调整到指向关键字21，即mid=8。
　　　　（1，3，5，7，9，11，13，17，21，28，32）
　　　　　　　　　　　　　　　↑ 　　　　↑　　　↑
　　　　　　　　　　　　　　　low　　　mid　　high
　(2)再将mid所指向的元素与key进行比较，因为key=28，大于21，说明待查找的关键字一定位于mid和high之间。所以下面的查找工作仍然只需在[mid+1,high]中进行。于是指针low指向mid+1的位置，即low=9，也就是指向关键字28，并将mid调整到指向关键字28，即mid=9。high保持不变。
　（1，3，5，7，9，11，13，17，21，28，32）
　　　　　　　　　　　　　　　 　　　↑　　↑
　　　　　　　　　　　　　　　　　　mid　high
　　　　　　　　　　　　　　　　　　low
(3)接下来仍然将mid所指元素与key进行比较，比较相等，查找成功，返回mid的值9。
假设要查找的关键字key为29，那么上述的查找还要继继续下去。由于当前mid所指的元素是28，小于29，因此下面的查找工作仍然只需在[mid+1,high]中进行。将指针iow指向mid+1的位置，并调整指针mid的位置。这时指针mid,low与high三者重合，都指向关键字32，它们的值都为10。
　（1，3，5，7，9，11，13，17，21，28，32）
　　　　　　　　　　　　　　　 　　　　　↑
　　　　　　　　　　　　　　　　　　　　high
　　　　　　　　　　　　　　　　　　　　mid
　　　　　　　　　　　　　　　　　　　　low
再将mid所指的元素与key进行比较，因为key=29,小于32，说明待查找的关键字一定位于low和mid之间。所以下面的查找工作仍然只需在[low,mid-1]中进行。于是令指针high指向mid-1的位置，即high=9，也就是指向关键字28.这是指针high小于指针low，这表明本次查找失败。
```

3. 代码实现：

```c++
int Binary_Seaarch(SSTable L,ElemType key){
    int low=0,high=L.TableLen-1,mid;
    while(low <= high) {
        // 取中间位置
        mid = (low+high) / 2;
        if(L.elem[mid] == key) return mid;	// 查找成功返回所在位置
        else if(L.elem[mid] > key) high = mid-1;	// 从前半部分继续查找
        else low = mid+1;	// 从后半部分继续查找
    }
    return -1;	// 查找失败
}
```

4. **注意：**

> 当$\color{blue}mid = ⌊(low + high)/2⌋$​
>
> 如果当前low和high之间有**奇数**个元素，则 mid 分隔后，左右两部分元素个数相等。
>
> 如果当前low和high之间有**偶数**个元素，则 mid 分隔后，左半部分⽐右半部分少⼀个元素。
>
> **折半查找的判定树中，若$\color{orange}mid = ⌊(low + high)/2⌋$​​​，则对于任何⼀个结点，必有：右⼦树结点数-左⼦树结点数=0或1。**
>
> 折半查找的判定树一定是平衡二叉树。

5. **折半查找的时间复杂度 = $O(log_2n)$​**
6. 折半查找的顺序不一定比顺序查找快
7. 判定树：

![4](C:/Users/XF/Desktop/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E6%9F%A5%E6%89%BE/img/4.png)

### 3.分块查找

**知识总览：**

![5](C:/Users/XF/Desktop/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E6%9F%A5%E6%89%BE/img/5.png)

1. 概念：也叫索引顺序查找，算法实现除了需要查找表本身之外，还需要根据查找表建立一个索引表。建立的索引表要求按照关键字进行升序排序，查找表要么整体有序，要么分块有序。

> **分块有序**：指的是第二个子表中所有关键字都要大于第一个子表中的最大关键字，第三个子表的所有关键字都要大于第二个子表中的最大关键字，依次类推。

2. 算法原理

> 分块查找，又称索引顺序查找，算法过程如下： ①在索引表中确定待查记录所属的分块（可顺序、可折半） ②在块内顺序查找

3. 代码实现

```c++
typedef struct{
    ElemType maxValue;
    int low,high;
}Index;
```

4. 若查找表是“动态查找表”，更好的实现⽅式——链式存储

## 二、树表查找







## 三、散列表查找

**知识总览：**

![6](img\6.png)

### 1.概念

1. 散列表定义：散列表（Hash Table），⼜称哈希表。是⼀种*数据结构*。特点是：数据元素的*关键字*与其*存储地址*直接*相关*。
2. 如何建⽴“关键字” 与“存储地址” 的联系？

> 通过“散列函数（哈希函数）”：Addr=H(key)

3. 
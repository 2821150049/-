# 变量和内存分区

## 一、内存分区

### 1.数据类型

1. 为什么要有数据类型

```
数据类型由编译器创建，为了更好的管理内存空间
```

2. 数据类型别名`typedef`

使用

> 简化结构体`struct`关键字

```c++
typedef struct Person{
  char name[];  
};
```

> $\color{red}{区分数据类型}$

```c++
char* p1,p2;
// p1是char* 而p2是char类型
typedef char* pchar;
pchar p1,p2;
// p1是char* p2是char*类型
```

> 提高移植性

```c++
typedef int My_Int;
My_Int a = 10;
```

3. `void`数据类型（无类型）

```
void字面意思"无类型"，void* 无类型指针，也可叫万能指针
```

> 无类型 不可以通过无类型创建变量，编译器不知道分配多少内存空间。

```c++
void a;// 错误的书写方法
```

> 用途：限定函数的返回值，限定函数参数

```c
void func(void){
    return 10;
}
// 调用
func(10,10);
/*
	会报错
*/
```

> C语言是一个不严谨的语言，不限定类型依旧可以跑起来

```c++
func(){
    return 10;
}
// 调用
func(10,10);
/*
	依旧可以跑起来，没有错误和警告
*/
```

> void * 万能指针

```c
void *p = NULL;
sizeof(p);
// 大小4字节
int * pInt = NULL;
char* pchar = NULL;
pInt = pchar;	// 类型不同会报警告
pInt = (int *)pchar;	// 强转
pInt = p;	// 不报警告
```

4. `sizeof`

> 本质不是一个函数，是一个运算符，且返回值是无符号整型

```c
sizeof(int);
```

> 统计数组大小

```c
int arry[] = {1,2,3,4,5,6};
sizeof(arry);
// 24
```

**当数组名被传入函数中，会退化成一个指针指向数组的首地址**

**注意：当`unsigned `和`signed`进行运算时，系统会讲`si`转换成`uns`类型**

### 2.变量

> 变量的修改方式

```c
// 1. 直接修改
int a = 10;
a = 20;
// 2. 间接修改
int *p = &a;
*p = 200;
```

### 3.内存分区

1. 程序运行前

> 代码区
>
> ​	共享的
>
> ​	只读的
>
> 数据区
>
> ​	静态变量、全局变量、常量
>
> ​	已初始化	data
>
> ​	未初始化	bss

2. 程序运行之后

> 代码区
>
> ​	共享的
>
> ​	只读的
>
> 数据区
>
> ​	静态变量、全局变量、常量
>
> ​	已初始化	data
>
> ​	未初始化	bss
>
> **栈区**
>
> ​	由编译器自动分配，存放函数参数，返回值，局部变量等。
>
> 堆区
>
> ​	是一个大容量容器，远大于栈，用于动态分配内存

3. 静态变量和全局变量

> 静态变量：在程序运行前就已经分配好了内存
>
> 生命周期在程序运行结束后结束
>
> 默认属于内部链接属性，在当前文件中使用

```c
static int a;	// 全局作用域，但是实在当前文件下才能使用
void test01(){
    static int b;	// 局部作用域
}
extern int g_a = 10;	// 默认情况是加了的
```

4. 常量

> `const`修饰的常量

```c
// 全局的
const int a = 10;	// 不可直接修改，也不可以间接修改，受到常量区保护
// 局部的
void test01(){
    const int b = 10;	// 局部作用域的伪常量，不可以直接修改，但是可以间接修改。
    // int arr[b]; 这样会报错，因为是b不是真正意义上的常量
}
```

> 字符串常量，字符串常量是共享的

```c
void test01(){
    char* p1 = "hello world";
    char* p2 = "hello world";
    char* p3 = "hello world";
}
// p1,p2,p3地址一样
```

4. 函数调用流程

> 宏函数

```c
// 保证运算的完整性
#define MyAdd(x,y)  ((x)+(y))	// 宏函数
// 会将x，y直接替换
// 使用场景
	// 将频繁短小的函数，封装为宏函数
// 优点：空间换时间
```

> 函数调用流程